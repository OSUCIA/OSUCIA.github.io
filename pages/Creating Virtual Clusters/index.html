<!DOCTYPE html>
<html>

  <head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Virtual HPC</title>
	<meta name="description" content="OSU Cyberinsfrastructure Association">
	
	<link rel="canonical" href="/pages/Creating%20Virtual%20Clusters/">
	<link rel="alternate" type="application/rss+xml" title="OSU CIA" href="/feed.xml" />
	
	<!-- <link rel="stylesheet" href="/css/main.css"> -->

	<link rel="stylesheet" type="text/css" href="http://apps.bdimg.com/libs/bootstrap/3.3.0/css/bootstrap.min.css">
	<!-- <link rel="stylesheet" type="text/css" href="http://apps.bdimg.com/libs/fontawesome/4.2.0/css/font-awesome.min.css"> -->
	<!-- <link rel="stylesheet" type="text/css" href="/static/css/bootstrap.min.css"> -->
	

	<link rel="stylesheet" type="text/css" href="/static/css/index.css">
	
	<!-- <script type="text/javascript" src="/static/js/jquery-1.11.1.min.js"></script>
	<script type="text/javascript" src="/static/js/bootstrap.min.js"></script> -->

	<script type="text/javascript" src="http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js"></script>
	<script type="text/javascript" src="http://apps.bdimg.com/libs/bootstrap/3.3.0/js/bootstrap.min.js"></script>

	<script type="text/javascript" src="/static/js/index.js"></script>
	
	<link rel="stylesheet" type="text/css" href="http://apps.bdimg.com/libs/highlight.js/8.4/styles/monokai_sublime.min.css">
	<!-- <link rel="stylesheet" type="text/css" href="http://apps.bdimg.com/libs/highlight.js/8.4/styles/railscasts.min.css"> -->
	<!-- <link rel="stylesheet" type="text/css" href="http://apps.bdimg.com/libs/highlight.js/8.4/styles/monokai.min.css"> -->
	<!-- <script type="text/javascript" src="http://apps.bdimg.com/libs/highlight.js/8.4/languages/dos.min.js"></script> -->
	<script type="text/javascript" src="http://apps.bdimg.com/libs/highlight.js/8.4/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>

	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?b636473d6ffa17615f94e5db1459ea81";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

</head>


 <!--  <body data-spy="scroll" data-target="#myAffix"> -->
  <body>

    <header>

<!-- navbar -->
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">OSU CIA</a>
      <p class="navbar-text">The Supercomputing Club</p>
    </div>
    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav navbar-right">

        
          <li>
        
          <a href="/"><span class="glyphicon glyphicon-th-large"></span> Home</a></li>

        
          
            
              <li>
            
            <a href="/pages/By-Laws/"><span class="glyphicon "></span> By-Laws</a></li>
          
        
          
            
              <li>
            
            <a href="/pages/Constitution/"><span class="glyphicon "></span> Constitution</a></li>
          
        
          
            
              <li class="active">
              
            <a href="/pages/Creating%20Virtual%20Clusters/"><span class="glyphicon "></span> Virtual HPC</a></li>
          
        
          
            
              <li>
            
            <a href="/pages/Minutes/"><span class="glyphicon "></span> Minutes</a></li>
          
        
          
        
          
        
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

</header>



    <div id="main" class="container main">
      <p>###Prerequisites</p>

<p>####Desktop or laptop with</p>

<ul>
  <li>An Intel-compatible processor with 2 or more cores</li>
  <li>At least 4 GB RAM</li>
  <li>At least 20 GB free disk space</li>
</ul>

<p>####Download Lubuntu (16.04, 64-bit version)</p>

<p>http://tiger.hpc.okstate.edu/lubuntu-16.04.1-alternate-amd64.iso<br />
Or http://cdimages.ubuntu.com/lubuntu/releases/xenial/release/lubuntu-16.04-alternate-amd64.iso<br />
md5sum:</p>
<ul>
  <li>c773824ab270455471a9086ee29242eb *lubuntu-16.04.1-alternate-amd64.iso</li>
</ul>

<p>####Download &amp; Install VirtualBox: https://www.virtualbox.org/wiki/Downloads</p>

<p>#Step One: Setup VM for master node</p>

<p>Create VM / Configure virtual hardware<br />
New VM</p>
<div class="language-text highlighter-rouge"><pre class="highlight"><code>Name: node0
Type: Linux
Version: Ubuntu 64-bit
Memory size: 1024 MB
Hard drive: Create a virtual hard drive now
Hard drive file type: VDI (the default option)
Storage on physical hard drive: Dynamically allocated
File location and size
    Name: node0 (default location / name)
    Size: 8.00 GB (default)
Create
</code></pre>
</div>
<p>Open settings for the VM</p>
<div class="language-text highlighter-rouge"><pre class="highlight"><code>Network
	Adapter 1
		Enabled
		Attached to: NAT
	Adapter 2
		Enabled
		Attached to: Internal Network
		Name: cluster
</code></pre>
</div>
<p>Install Linux<br />
Start the VM<br />
Should be prompted for startup disk, if not click Devices menu → CD/DVD Devices → Choose a virtual CD/DVD disk file, choose the lubuntu ISO file. If you have to click the menu, then you’ll have to reset the power to the VM (Machine menu → Reset).</p>

<p>Linux Installation</p>
<div class="language-text highlighter-rouge"><pre class="highlight"><code>Choose English
Choose Install Lubuntu
Installation language: English (again, default)
Country: United States (default)
Detect keyboard layout: No
Keyboard country: English/US (default)
Keyboard layout: English/US
(Stuff will now happen and you’ll have to wait a few seconds.)
Primary network interface: enp0s3 (you may get something different; this was the default)
(system attempts to get IP address and do automatic network config)
Hostname: node0
Full name for new user: pi
Username: pi
Password: raspberry
Encrypt home directory: No (default)
(system attempts to auto-detect time zone; want it to be “America/Chicago”)
Choose whether detected time zone is correct
Partitioning method: Guided - use entire disk (default)
Select disk to partition: SCSI3 (default)
(system will create partition configuration)
Write changes to disks?: Yes
(Linux will now begin installing to the VM’s hard drive.)
HTTP proxy: (leave blank, default)
(Installation will continue)
Install GRUB to the master boot record: Yes (default)
System clock set to UTC?: Yes (default)
(Installation complete)
</code></pre>
</div>
<p>Configure installed system
Log in as pi
Open terminal (menu → System Tools → LXTerminal)</p>

<h2 id="install-updates-and-needed-packages">Install updates and needed packages</h2>

<p>First, you have to update Lubuntu’s lists of the most recent versions of the programs, “packages”, that the system has.<br />
Second, you have Lubuntu use this list to automatically download the newest versions of all of the installed packages and update them.<br />
In order to run these, we have to get administrative privileges. We do this by starting the command with <code class="highlighter-rouge">sudo</code> - this tells the terminal to run the command as “root”, which is Linux’s version of Administrator.<br />
The command itself uses <code class="highlighter-rouge">apt-get</code> which is the program that we’ll use to update all of the files on this system.</p>
<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo apt-get update
sudo apt-get upgrade
</code></pre>
</div>
<p>Now we’ll use the <code class="highlighter-rouge">apt-get</code> command to actually get and application - or in this case 9 of them at once! Each name you see after <code class="highlighter-rouge">install</code> is a different program that we’re asking to be installed.</p>
<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo apt-get install nano vim curl openssh-server nfs-kernel-server build-essential git mpich mpich-doc
</code></pre>
</div>

<h2 id="setup-network-interface-for-internal-cluster-network">Setup network interface for internal cluster network</h2>
<p>Above we installed two different network adapters, one that connects to the internet through your real computer, and one that is just connected to the internal “VM only” network.<br />
Now we need to configure the “VM only” adapter to talk to all of the other machines.</p>
<ol>
  <li>
    <p>First figure out the device name for the network adapter using the NetworkManager Command Line Interface <code class="highlighter-rouge">nmcli</code>.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>nmcli device
</code></pre>
    </div>
    <p>The device you want will probably be in red; I got “enp0s8”</p>
  </li>
  <li>
    <p>Now that we know the device to configure, we need to actually configure it.<br />
We pass <code class="highlighter-rouge">nmcli</code> the <code class="highlighter-rouge">c</code> flag, to indicate we’re wanting to modify a ‘c’onnection.<br />
Then we tell it we want to <code class="highlighter-rouge">add</code> a connection named (<code class="highlighter-rouge">con-name</code>) <code class="highlighter-rouge">cluster</code><br />
We then give it the <code class="highlighter-rouge">ifname</code> (<strong>i</strong>nter<strong>f</strong>ace <strong>name</strong>), which is the name fo the devide we found above.<br />
Next we tell it the <code class="highlighter-rouge">type</code> of connection is <code class="highlighter-rouge">ethernet</code>, and give it an <code class="highlighter-rouge">ipv4</code> address of <code class="highlighter-rouge">192.168.13.0/24</code><br />
Finally, we pass it <code class="highlighter-rouge">gw4</code> to tell it the <strong>g</strong>ate<strong>w</strong>ay for ipv<strong>4</strong> is its own ipv4 address that we just told it.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo nmcli c add con-name cluster ifname enp0s8 <span class="nb">type </span>ethernet ip4 192.168.13.0/24 gw4 192.168.13.0
</code></pre>
    </div>
  </li>
  <li>
    <p>Give this network interface a lower priority so the system doesn’t try to use it for internet traffic
Again we’re dealing with a <code class="highlighter-rouge">c</code>onnection, but this time we’re <code class="highlighter-rouge">modify</code>-ing it.
We have to tell it the <code class="highlighter-rouge">id</code> of the cluster, which is the con-name we gave it above: <code class="highlighter-rouge">cluster</code>.
Finally we tell it that we want to modify the <code class="highlighter-rouge">ipv4.route-metric</code> by setting it to 101. This tells Lubuntu to prioritize this network less that the direct connection to the internet.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo nmcli c modify id cluster ipv4.route-metric 101
</code></pre>
    </div>
  </li>
</ol>

<h3 id="setup-nfs-share">Setup nfs share</h3>
<ol>
  <li>
    <p>Use <code class="highlighter-rouge">mkdir</code> to <strong>m</strong>a<strong>k</strong>e the <strong>dir</strong>ectory that we’ll share. We’re naming it <code class="highlighter-rouge">shared</code>, and placing it in the root directory.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo mkdir /shared
</code></pre>
    </div>
  </li>
  <li>
    <p>Now we use <code class="highlighter-rouge">chown</code> to <strong>ch</strong>ange the <strong>own</strong>ership of the directory we made. This just makes sure it is owned by our user (<code class="highlighter-rouge">pi</code>) on our machine (<code class="highlighter-rouge">pi</code>).</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo chown pi:pi /shared
</code></pre>
    </div>
  </li>
  <li>
    <p>Lets make a test file on this virtual machine, then we can see if it appears on the others.
We’ll tell the shell to <code class="highlighter-rouge">echo</code> our sentence into (<code class="highlighter-rouge">&gt;</code>) a new file in our <code class="highlighter-rouge">shared</code> folder, called <code class="highlighter-rouge">test</code>.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="nb">echo</span> “My icebox is full of lagomorphs!” &gt; /shared/test.txt
</code></pre>
    </div>
  </li>
  <li>
    <p>Finally lets configure the settings of how to share the files in our <code class="highlighter-rouge">shared</code> folder.<br />
To do this we need to add line to the file <code class="highlighter-rouge">/etc/exports</code>: <code class="highlighter-rouge">/shared 192.168.13.0/24(rw,no_root_squash,async,no_subtree_check)</code><br />
You can do this with either <code class="highlighter-rouge">nano</code> or <code class="highlighter-rouge">vim</code>, but we’ll use <code class="highlighter-rouge">nano</code></p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo nano /etc/exports
</code></pre>
    </div>

    <p>Make your changes and press ctrl-x, press y to save your changes, and press enter to keep the same filename.<br />
We also need to update nsf to use these new settings. We do this by <code class="highlighter-rouge">export</code>ing the settings. The <code class="highlighter-rouge">ra</code> flags tell it to update all of its settings, and remove any invalid kernels and do generaly cleanup.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo exportfs -ra
</code></pre>
    </div>
  </li>
</ol>

<h3 id="add-etchosts-entries-use-nano-or-vim">Add /etc/hosts entries (use nano or vim)</h3>
<p>Our next step is to tell Lubuntu what the IP addresses of all of the nodes are. This step isn’t <strong>necessary</strong> per se, but it greatly simplifies your code later. This lets you refer to the other nodes by their name, instead of needing to remember their IPs.</p>

<p>To use <code class="highlighter-rouge">nano</code> to do this you’ll run</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo nano /etc/hosts
</code></pre>
</div>

<p>Then you’ll add these to the file:</p>

<div class="language-text highlighter-rouge"><pre class="highlight"><code>192.168.13.0	node0
192.168.13.1	node1
192.168.13.2	node2
192.168.13.3	node3
192.168.13.4	node4
192.168.13.5	node5
192.168.13.6	node6
192.168.13.7	node7
</code></pre>
</div>

<p>Remove or comment out line <code class="highlighter-rouge">127.0.0.1	node0</code>. We only want the name <code class="highlighter-rouge">node0</code> to resolve to the cluster address, never the loopback address.</p>

<h3 id="setup-ssh-keys">Setup ssh keys</h3>
<p>The way our nodes talk to eachother is through a secure communication method called ssh. Unfortunately starting a session of ssh normally requires you to enter a username and password each time, which would make our system a lot less automated.<br />
To solve this we’ll generate an SSH key that doesn’t have a password, and just use that key for each node’s communication.<br />
To do this we use <code class="highlighter-rouge">ssh-keygen</code> and tell it the <code class="highlighter-rouge">t</code>ype of key we want is <code class="highlighter-rouge">rsa</code>, which is to say a key generated with an rsa algorithm.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>ssh-keygen -t rsa
</code></pre>
</div>

<p>Hit enter through all the prompts.<br />
Now we want to take the keys generated and add them to our authorized keys list.<br />
First we use <code class="highlighter-rouge">cat</code>, which in this usage just prints the contents of the file you give it - we’ll give it <code class="highlighter-rouge">~/.ssh./id_rsa.pub</code>.<br />
Now that we’re printing the keys, lets tell the console to output to our authorized keys list and just add it to that file. This is done by using <code class="highlighter-rouge">&gt;&gt;</code> to indicate we want to append the information to a file, and <code class="highlighter-rouge">~/.ssh/authorized_keys</code> is the location we want to add it to.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre>
</div>

<h1 id="setup-a-slave-node-to-the-point-of-copying-ssh-keys">Setup a slave node to the point of copying ssh keys</h1>

<h2 id="run-through-the-above-process-to-setup-all-of-the-slave-nodes">Run through the above process to setup all of the slave nodes.</h2>

<div class="language-text highlighter-rouge"><pre class="highlight"><code>Setup VM(s) for slave node(s)
Create VM / Configure virtual hardware
Follow procedure for master node substituting “node1” (or whatever number) for “node0”.
Install Linux
Follow procedure for master node substituting “node1” (or whatever number) for “node0”.
Configure installed system
Log in as pi
Open terminal
</code></pre>
</div>

<h3 id="install-updates-and-needed-packages-1">Install updates and needed packages</h3>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo apt-get update
sudo apt-get upgrade
sudo apt-get install nano vim curl openssh-server mpich mpich-doc nfs-common
</code></pre>
</div>

<h3 id="setup-network-interface-for-internal-cluster-network-1">Setup network interface for internal cluster network</h3>

<p>This time we’ll run it almost the same as above, but we won’t have the same IP address for the node as for the gateway. We want this node to use node0 as the gateway, so we input the IP for node0 after <code class="highlighter-rouge">gw4</code>.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo nmcli c add con-name cluster ifname enp0s8 <span class="nb">type </span>ethernet ip4 192.168.13.1/24 gw4 192.168.13.0
sudo nmcli c modify id cluster ipv4.route-metric 101
</code></pre>
</div>

<h3 id="make-sure-the-internal-cluster-network-is-working">Make sure the internal cluster network is working</h3>

<p>To do this we’ll <code class="highlighter-rouge">ping</code> the master node, if the master node responds we’re good to go. If not, make sure you didn’t skip any steps above. If you’re in the training session and this doesn’t work, now is a good time to put up your red sticky.</p>
<div class="language-bash highlighter-rouge"><pre class="highlight"><code>ping 192.168.13.0
</code></pre>
</div>

<h3 id="mount-the-folder-we-shared-with-nsf">Mount the folder we shared with nsf</h3>

<p>We need to get access to that shared folder on all of the virtual machines, so first we <strong>m</strong>a<strong>k</strong>e the <strong>dir</strong>ectory on this machine, then we <code class="highlighter-rouge">mount</code> the directory from the master node. This will keep this folder the same across all of the nodes.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo mkdir /shared
sudo mount 192.168.13.0:/shared /shared
</code></pre>
</div>

<p>Use <code class="highlighter-rouge">ls</code> to look for /shared/test.txt to see if the mount is good. If you don’t see the file, again make sure you didn’t skip any steps on accident. If you do see the file, use <code class="highlighter-rouge">cat</code> to see if the correct sentence is in the file.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>ls /shared/text.txt
cat /shared/text.txt
</code></pre>
</div>

<h2 id="set-the-nfs-share-to-mount-automatically">Set the nfs share to mount automatically</h2>

<p>We do this by editing the file that Lubuntu checks to see if there are any external filesystems to mount when it boots up.<br />
Add line to <code class="highlighter-rouge">/etc/fstab</code>: <code class="highlighter-rouge">192.168.13.0:/shared  /shared  nfs  rw,noatime,hard,intr,vers=3  0 0</code></p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>nano /etc/fstab
</code></pre>
</div>

<p>Then just copy the line above into the file and close it like the last time we used <code class="highlighter-rouge">nano</code>.<br />
Now we’ll reboot</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo reboot
</code></pre>
</div>

<p>Log in and make sure that /shared is mounted by again running <code class="highlighter-rouge">ls</code></p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>ls /shared/text.txt
</code></pre>
</div>

<h3 id="add-etchosts-entries">Add /etc/hosts entries</h3>

<p>Complete this just like how we did on node0</p>

<div class="language-text highlighter-rouge"><pre class="highlight"><code>192.168.13.0	node0
192.168.13.1	node1
192.168.13.2	node2
192.168.13.3	node3
192.168.13.4	node4
192.168.13.5	node5
192.168.13.6	node6
192.168.13.7	node7
</code></pre>
</div>

<p>Remove or comment out line “127.0.0.1	node1”. We only want the name “node1” to resolve to the cluster address, never the loopback address.</p>

<h3 id="copy-ssh-keys-from-node0">Copy ssh keys from node0</h3>
<p>Now we have to make sure each node has the ssh key for node0, so that they can communicate without a username and password each time.<br />
We’ll do this using <code class="highlighter-rouge">scp</code> or <strong>s</strong>ecure <strong>c</strong>o<strong>p</strong>y. We use scp to make sure no one can listen in on the conversation and copy the key. It’s not really necessary in this situation, but it’s a good practice.<br />
When we use scp, we’ll tell it that we’re copying an entire di<strong>r</strong>ectory with <code class="highlighter-rouge">-r</code> - in this case we’re copying from <code class="highlighter-rouge">node0</code>. We can just use the name because we set up all of the <code class="highlighter-rouge">/etc/hosts/</code> entries above. Then we give it the host <code class="highlighter-rouge">node0</code> and the file <code class="highlighter-rouge">~/.ssh</code>.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>scp -r node0:~/.ssh ~
</code></pre>
</div>

<h2 id="run-the-above-settings-for-the-other-6-slave-nodes-substiting-the-number-of-the-node-youre-working-on-anytime-it-says-node1">Run the above settings for the other 6 slave nodes, substiting the number of the node you’re working on anytime it says <code class="highlighter-rouge">node1</code>.</h2>

<h1 id="test-mpi">Test MPI</h1>

<p>MPI is the framework for sending messages and data back and forth between the nodes, so we’re testing to be sure that works.<br />
From this point forward we can do everything from the master node, <code class="highlighter-rouge">node0</code>.</p>

<h2 id="hello-world">Hello World</h2>

<ol>
  <li>
    <p><strong>C</strong>hange <strong>d</strong>irectories into the <code class="highlighter-rouge">shared</code> directory.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="nb">cd</span> /shared
</code></pre>
    </div>

    <p>Now you’re operating from inside the folder we have being shared to all of the nodes.</p>
  </li>
  <li>
    <p><strong>M</strong>a<strong>k</strong>e the <strong>dir</strong>ectory <code class="highlighter-rouge">hello_world</code> in this directory.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>mkdir hello_world
</code></pre>
    </div>
  </li>
  <li>
    <p><strong>C</strong>hange <strong>d</strong>irectories into the <code class="highlighter-rouge">hello_world</code> directory.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="nb">cd </span>hello_world
</code></pre>
    </div>
  </li>
  <li>
    <p>Download the programs we’ll use to test.<br />
We’ll do this by using <code class="highlighter-rouge">wget</code> to download the files from a url.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>wget https://github.com/OSU-HPCC/example_submission_scripts/raw/master/compiling_and_running/mpi/makefile
wget https://github.com/OSU-HPCC/example_submission_scripts/raw/master/compiling_and_running/mpi/hello_world_mpi.c
</code></pre>
    </div>
  </li>
  <li>
    <p>Use the program <code class="highlighter-rouge">make</code> to automatically compile the files your just downloaded.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>make
</code></pre>
    </div>
  </li>
  <li>
    <p>Run the program!<br />
To run the program we’ll use <code class="highlighter-rouge">mpirun</code>, which runs it using <code class="highlighter-rouge">mpi</code>.<br />
We tell it the <strong>n</strong>umber of <strong>p</strong>rocesses to use by giving it the <code class="highlighter-rouge">np</code> flag, then we tell it to run with <code class="highlighter-rouge">2</code> processes for now.<br />
Then we tell it which two nodes will <code class="highlighter-rouge">host</code> the program.<br />
Finally we tell it the location of the program itself, which is <code class="highlighter-rouge">./hello_world_mpi</code></p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>mpirun -np 2 -host node0,node1 ./hello_world_mpi
</code></pre>
    </div>
  </li>
</ol>

<p>##GalaxSee
This is a slightly more fun program.</p>

<ol>
  <li>
    <p>For this one we need to install a new program that GalaxSee uses.<br />
Again, we’ll use <code class="highlighter-rouge">apt-get install</code> to get the program.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo apt-get install libx11-dev
</code></pre>
    </div>
  </li>
  <li>
    <p>Make sure you’re in the <code class="highlighter-rouge">shared</code> folder again.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="nb">cd</span> /shared
</code></pre>
    </div>
  </li>
  <li>
    <p>Download the GalaxSee program itself using <code class="highlighter-rouge">wget</code> again.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>wget https://www.shodor.org/refdesk/Resources/Tutorials/MPIExamples/Gal.tgz
</code></pre>
    </div>
  </li>
  <li>
    <p>Now we have to uncompress the program, because it’s all stored in Gal.tgz but we need access to the files.<br />
We do this with the <code class="highlighter-rouge">tar</code> command, and use a small slew of flags to tell it to extract it to the current folder.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>tar -zxvf Gal.tgz
</code></pre>
    </div>
  </li>
  <li>
    <p><strong>C</strong>hange <strong>d</strong>irectories into the new folder that was made.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="nb">cd </span>Gal
</code></pre>
    </div>
  </li>
  <li>
    <p>Modify the <code class="highlighter-rouge">Makefile</code> to compile the program to work on our particular cluster setup.<br />
To do this with <code class="highlighter-rouge">nano</code> use</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>nano Makefile
</code></pre>
    </div>

    <p>Then make a few changes.<br />
Change <code class="highlighter-rouge">CC = mpicc</code> to <code class="highlighter-rouge">CC = mpicxx</code><br />
Change <code class="highlighter-rouge">/opt/mpich/include</code> to <code class="highlighter-rouge">/usr/include/mpich</code> in the CFLAGS definition.
  Change <code class="highlighter-rouge">/opt/mpich/lib</code> to <code class="highlighter-rouge">/usr/lib/mpich</code> in the LDFLAGS definition.</p>
  </li>
  <li>
    <p>Compile the program.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code>make
</code></pre>
    </div>
  </li>
</ol>

<p>###To run the program on just one node</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>mpirun -np 1 -host node0 ./GalaxSee 1000 5.5 10000.0 1
</code></pre>
</div>

<p>###To run on two nodes</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>mpirun -np 2 -host node0,node1 ./GalaxSee 1000 5.5 50000.0 1
</code></pre>
</div>

<p>###To run the node on even more nodes</p>

<p>Just increase the number after <code class="highlighter-rouge">-np</code>, and keep adding more node names to the list of nodes. You have 8 nodes right now.</p>

<p>####Try opening a terminal and starting the <code class="highlighter-rouge">top</code> command on the slave node(s) before starting GalaxSee on the master node. You should see a GalaxSee process appear in the list of processes and disappear when the program finishes.</p>

<p>#TinyTitan Stuff</p>

<h2 id="optional-connect-xbox360-controller">(Optional) Connect Xbox360 Controller.</h2>

<p>If you don’t have a controller or can’t get it connected, you can still do everything with your keyboard and mouse.<br />
If running linux on your physical host (i.e. desktop or laptop) add yourself to the group <code class="highlighter-rouge">vboxusers</code>.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo usermod --groups vboxusers --append username
</code></pre>
</div>

<p>Log out and back in, or do some hacky stuff to get your groups reevaluated and start virtualbox from command line (e.g. <code class="highlighter-rouge">newgrp vboxusers; newgrp originalgroup; virtualbox &amp;</code>).</p>

<p>Edit settings for node0 in VirtualBox</p>
<div class="language-text highlighter-rouge"><pre class="highlight"><code>	USB
		Create New Filter
		Edit the filter
			Name: Xbox360 Controller
			Vendor ID: 045e
			Product ID: 028e
</code></pre>
</div>

<p>Start node0<br />
Wait for node0 to complete startup<br />
Start node1<br />
Log into node0<br />
Start terminal<br />
Check to see if the VM sees the Xbox360 controller</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>lsusb
</code></pre>
</div>

<h2 id="install-needed-packages">Install needed packages</h2>

<p>On the master node run: <code class="highlighter-rouge">sudo apt-get install libglew-dev libgles2-mesa-dev libglfw3 libglfw3-dev libfreetype6-dev xboxdrv</code><br />
On the slave nodes run: <code class="highlighter-rouge">sudo apt-get install lubglew1.13 libglfw3</code></p>

<h2 id="install-tinytitan-programs">Install TinyTitan programs</h2>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="nb">cd</span> /shared
mkdir TinyTitan
<span class="nb">cd </span>TinyTitan
git clone https://github.com/TinyTitan/SPH
<span class="nb">cd </span>SPH
cp makefile_jetson makefile_lubuntu
sudo apt-get install pkg-config
pkg-config glfw3 --libs --cflags
nano makefile_lubuntu
</code></pre>
</div>

<p>Add <code class="highlighter-rouge">-L/usr/lib/x86_64-linux-gnu</code> to the CLIBS definition.<br />
Change <code class="highlighter-rouge">-lglfw3</code> to <code class="highlighter-rouge">-lglfw</code>.<br />
Add <code class="highlighter-rouge">liquid_gl.c</code> into the compile line before <code class="highlighter-rouge">mover_gl.c</code>.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>make -f makefile_lubuntu
</code></pre>
</div>

<h2 id="optional-start-the-xbox-controller-driver">(Optional) Start the Xbox controller driver</h2>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo xboxdrv --mouse --axismap -Y1<span class="o">=</span>Y1 --config /shared/TinyTitan/SPH/controller_2.cnf --silent &amp;
</code></pre>
</div>

<h2 id="run-sph-with-two-threads-the-absolute-minimum-one-for-display-and-one-for-computation">Run SPH with two threads (the absolute minimum; one for display and one for computation)</h2>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>mpirun -np 2 -hosts node0,node1 bin/sph.out
</code></pre>
</div>

<h4 id="mouse-and-xbox-controller-are-working-but-menu-sometimes-doesnt-appear-when-hitting-start-button-on-xbox-controller-esc-key-on-keyboard-works-move-cursor-over-the-terminal-option-and-hit-the-a-key-on-either-the-keyboard-or-xbox-controller-to-exit-the-l-key-toggles-between-liquid-and-particle-view-which-color-codes-the-individual-threads">Mouse and xbox controller are working but menu (sometimes?) doesn’t appear when hitting start button on xbox controller. Esc key on keyboard works. Move cursor over the Terminal option and hit the A key on either the keyboard or xbox controller to exit. The L key toggles between liquid and particle view (which color codes the individual threads).</h4>

<p>#Notes</p>

<p>Same /etc/hosts file on all nodes<br />
Same user (with same UID) on all nodes<br />
Passwordless ssh<br />
Choose to either setup nfs server or synchronize home directories of all nodes<br />
Install mpi and other stuff</p>

<p>Ip forwarding on master node</p>

<p>https://jetcracker.wordpress.com/2012/03/01/how-to-install-mpi-in-ubuntu/<br />
libcr-dev mpich2 mpich2-doc</p>

<p>Create internal network (call it “Cluster”)</p>

<p>To make sudo not require a password:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo <span class="nb">echo</span> “pi <span class="nv">ALL</span><span class="o">=(</span>ALL<span class="o">)</span> NOPASSWD: ALL” &gt; /etc/sudoers.d/pi_nopasswd
</code></pre>
</div>

<p>Network config options:</p>
<ol>
  <li>Each VM has both NAT and internal network connections (simpler)</li>
  <li>Only master node has NAT; all VMs have internal network and route through master node (like HPCC’s Raspberry Pi cluster)</li>
</ol>

    </div>

    
    <div id="top" data-toggle="tooltip" data-placement="left" title="Back to top">
      <a href="javascript:;">
        <div class="arrow"></div>
        <div class="stick"></div>
      </a>
    </div>

    <footer class="">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <a href="mailto:cia@okstate.edu"><span class="glyphicon glyphicon-envelope"></span> cia@okstate.edu</a>
        <span class="point"> · </span>
        
          
          <a href="https://github.com/OSUCIA">
            <span class="icon">
              <svg viewBox="0 0 16 16">
                <path fill="#aaa" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
              </svg>
            </span>
            Github
            <!-- <span>OSUCIA</span> -->
          </a>
          
          
          <span class="point"> · </span>
          <span><a href="/feed.xml">RSS</a></span>
          <span class="point"> · </span>
          <span>OSU Cyberinsfrastructure Association</span>

      </div>
    </div>
  </div>
</footer>



    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
    var duoshuoQuery = {short_name:"hygblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
<!-- 多说公共JS代码 end -->

<!-- 在新窗口中打开 -->
  <script type="text/javascript">
    function addBlankTargetForLinks () {
      $('a[href^="http"]').each(function(){
          $(this).attr('target', '_blank');
      });
    }
    $(document).bind('DOMNodeInserted', function(event) {
      addBlankTargetForLinks();
    });
  </script>
  </body>
</html>
